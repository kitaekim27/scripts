#!/bin/bash

set -o errexit -o nounset -o noglob -o pipefail

THIS_SCRIPT=$(basename "$0")
readonly THIS_SCRIPT

info() {
    echo "$THIS_SCRIPT:" "$@"
}

error() {
    info "$@" >&2
}

if [ "$EUID" != 0 ]
then
    error "This script requires root privilege!"
    exit 1
fi

readonly SOURCE_DIR="/usr/src/initramfs"

BUILD_DIR=$(mktemp --directory --tmpdir "$THIS_SCRIPT.XXXXXXXXXX")
readonly BUILD_DIR

LINUX_VERSION=$(lslinux | fzf --header="Select a target linux kernel version.")
readonly LINUX_VERSION

# XXX: Note that it's better to disable some USE flags enabled system-wide here
#      (e.g, bluetooth).
GENERAL_USE="-elogind -systemd -X -bluetooth -networkmanager -dbus -mime -man"

info "Install busybox in the initramfs build directory."
KERNEL_DIR="/usr/src/linux-$LINUX_VERSION" USE="$GENERAL_USE make-symlinks" \
    emerge --root="$BUILD_DIR" sys-apps/busybox

info "Install tpm2-tools and cryptsetup in the initramfs build directory."
KERNEL_DIR="/usr/src/linux-$LINUX_VERSION" USE="$GENERAL_USE" \
    emerge --root="$BUILD_DIR" app-crypt/tpm2-tools sys-fs/cryptsetup

# Here, we need to install libgcc_s.so.* which is a hidden runtime dependency
# for pthread for cryptsetup...
#
# It's better to install it after installing all the packages necessary as rcopy
# will attepmpt to copy objects required by other packages like libc.so so that
# it will not copy incompatible objects...
#
# Excerpt from GNU libgcc doc: GCC provides a low-level runtime library,
# libgcc.a or libgcc_s.so.1 on some platforms. GCC generates calls to routines
# in this library automatically, whenever it needs to perform some operation
# that is too complicated to emit inline code for.
info "Copy libgcc_s.so.1 into the initramfs build directory."
GCC_VERSION="$(eselect gcc show | sed 's/x86_64-pc-linux-gnu-\(.*\)/\1/')"
LIBGCC_FILES="$(find "/usr/lib/gcc/x86_64-linux-gnu/$GCC_VERSION" -name "libgcc_s.so.[1-9]")"
for file in $LIBGCC_FILES
do
    rcopy "$file" "$BUILD_DIR"
    # Make symlinks so that ld.so can load the object properly.
    # We also can do this by modifying /etc/ld.so.conf or /etc/ld.so.conf.d.
    ld --symbolic "$file" "$BUILD_DIR/usr/lib/$(basename "$file")"
done

info "Create pseudo filesystem mounts points in the iniramfs build directory."
for directory in /proc /sys /run /dev
do
    mkdir --parents "$BUILD_DIR$directory"
done

info "Copy files in the source directory into the build directory."
find "$SOURCE_DIR" -mindepth 1 -maxdepth 1 -exec cp --archive {} "$BUILD_DIR" \;

info "Copy my scripts into the initramfs build directory."
mkdir --parents "$BUILD_DIR/usr/local/bin"
cp "$(locatebin mkpassphrase)" "$BUILD_DIR/usr/local/bin"

info "Install kernel modules into the initramfs build directory."
mkdir --parents "$BUILD_DIR/lib/modules/$LINUX_VERSION"
find "/lib/modules/$LINUX_VERSION" -mindepth 1 -maxdepth 1 \
    -exec cp --archive {} "$BUILD_DIR/lib/modules/$LINUX_VERSION" \;

# info "Install kernel firmwares into the initramfs build directory."
# mkdir --parents "$BUILD_DIR/lib/firmware"
# find /lib/firmware -mindepth 1 -maxdepth 1 \
#     -exec cp --archive {} "$BUILD_DIR/lib/firmware" \;

info "Build and install the initramfs into /boot."
( cd "$BUILD_DIR" && find . -mindepth 1 -print0 \
    | cpio --null --create --format="newc" \
    | gzip -9  > "/boot/initrd.img-$LINUX_VERSION" )

info "Successfully built the initramfs!"
info "Clean up the initramfs build directory."
rm --recursive "$BUILD_DIR"
