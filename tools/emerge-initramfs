#!/bin/bash

set -o errexit -o nounset -o noglob -o pipefail

this_script=$(basename "${0}")

info() {
	echo "${this_script}:" "${@}"
}

error() {
	info "${@}" >&2
}

if [ "${EUID}" != 0 ]
then
	error "This script requires root privilege!"
	exit 1
fi

source_dir="/usr/src/initramfs"
build_dir=$(mktemp --directory --tmpdir "${this_script}.XXXXXXXXXX")
linux_version=$(lslinux | fzf --header="Select a target linux kernel version.")

# XXX: Note that it's better to disable some USE flags enabled system-wide here
#	  (e.g, bluetooth).
general_use="-elogind -systemd -X -bluetooth -networkmanager -dbus -mime -man
             -su -pam lto"
export COMMON_FLAGS="-Os -march=native -pipe"

info "Install busybox in the initramfs build directory."
USE="${general_use} make-symlinks" \
	emerge --root="${build_dir}" sys-apps/busybox

info "Install tpm2-tools and cryptsetup in the initramfs build directory."
USE="${general_use}" \
	emerge --root="${build_dir}" app-crypt/tpm2-tools sys-fs/cryptsetup

# Here, we need to install libgcc_s.so.* which is a hidden runtime dependency
# for pthread for cryptsetup...
#
# Excerpt from GNU libgcc doc: GCC provides a low-level runtime library,
# libgcc.a or libgcc_s.so.1 on some platforms. GCC generates calls to routines
# in this library automatically, whenever it needs to perform some operation
# that is too complicated to emit inline code for.
info "Copy libgcc_s.so.1 into the initramfs build directory."
gcc_version="$(eselect gcc show | sed 's/x86_64-pc-linux-gnu-\(.*\)/\1/')"
# Why use `find` here? Note two things:
# 1. There may be two or more libgcc_s.so.1 (e.g, for x86 and x64).
# 2. Postfix ".1" is just for represeting binary interface... It's very unlikely
#	but it might be changed in the futhre.
find "/usr/lib/gcc/x86_64-pc-linux-gnu/${gcc_version}" -name "libgcc_s.so.[1-9]" \
	-exec rcopy "{}" "${build_dir}" \;
find /etc/ld.so.conf.d -name '*gcc-x86_64-pc-linux-gnu.conf' \
	-exec cp --archive "{}" "${build_dir}/etc/ld.so.conf.d" \;
chroot "${build_dir}" ldconfig

info "Create pseudo filesystem mounts points in the iniramfs build directory."
for directory in /proc /sys /run /dev
do
	mkdir --parents "${build_dir}${directory}"
done

info "Copy files in the source directory into the build directory."
find "${source_dir}" -mindepth 1 -maxdepth 1 -exec cp --archive {} "${build_dir}" \;

info "Copy my scripts into the initramfs build directory."
mkdir --parents "${build_dir}/usr/local/bin"
cp "$(locatebin mkpassphrase)" "${build_dir}/usr/local/bin"

info "Install kernel modules into the initramfs build directory."
mkdir --parents "${build_dir}/lib/modules/${linux_version}"
find "/lib/modules/${linux_version}" -mindepth 1 -maxdepth 1 \
	-exec cp --archive {} "${build_dir}/lib/modules/${linux_version}" \;

# info "Install kernel firmwares into the initramfs build directory."
# mkdir --parents "${build_dir}/lib/firmware"
# find /lib/firmware -mindepth 1 -maxdepth 1 \
#	 -exec cp --archive {} "${build_dir}/lib/firmware" \;

info "Build and install the initramfs into /boot."
( cd "${build_dir}" && find . -mindepth 1 -print0 \
	| cpio --null --create --format="newc" \
	| gzip > "/boot/initrd.img-${linux_version}" )

info "Successfully built the initramfs!"
info "Clean up the initramfs build directory."
rm --recursive "${build_dir}"
