#!/bin/bash
# Recursively copy the given executable.

set -o errexit -o nounset -o noglob -o pipefail

info() {
    echo "$(basename "$0"):" "$@"
}

error() {
    info "$@" >&2
}

if [ "$EUID" != 0 ]
then
    error "This script requires root privilege!"
    exit 1
fi

cp="cp --archive"
target="$(realpath "$1")"
newroot="$(realpath "$2")"
should_copy_libgcc_s=0

deep_copy() {
    local file="$1"
    if [ -e "$file" ]
    then
        return 0
    fi

    case "$file" in
    */libpthread.so.*)
        should_copy_libgcc_s=1
        ;;
    esac

    mkdir --parents "$newroot${file%/*}"
    $cp "$file" "$newroot$file"
    if [ -L "$file" ]
    then
        realfile=$(readlink -f "$file")
        mkdir --parents "$newroot${realfile%/*}"
        $cp "$realfile" "$newroot$realfile"
    fi

    dependencies=$(env --unset="LD_PRELOAD" ldd "$file" 2>/dev/null | sed -e '
        /\//!d;
        /=>/ {s/.*=>[[:blank:]]*\([^[:blank:]]*\).*/\1/};
        s/[[:blank:]]*\([^[:blank:]]*\) (.*)/\1/
    ') || :

    for dependency in $dependencies
    do
        deep_copy "$dependency"
    done
}

if [ ! -d "$newroot" ]
then
    error "$newroot is not a directory!"
    exit 1
fi

deep_copy "$target"

# libpthread loads libgcc_s using dlopen. Need to handle it.
if [ "$should_copy_libgcc_s" != 0 ]
then
    find / -maxdepth 1 -type d -iname 'lib*' \
        -exec find {} -type f -iname 'libgcc_s.so.[1-9]' \
            -exec deep_copy "{}" \; \;
fi
